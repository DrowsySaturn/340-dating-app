package com.datingapp.server.datapersistence;
/*
 * The purpose of this class is to read and write to the database.
 * It overloads the save() method, taking any database object and using try-catch-finally clauses
 *  to update or insert them into the database.
 *
 * @author Jonathan Cooper, William Buck
 * @version oct-18-2018
 */

import android.annotation.TargetApi;
import android.os.Build;
import android.os.RecoverySystem;
import android.os.strictmode.SqliteObjectLeakedViolation;

import com.datingapp.shared.datapersistence.ClassScraper;
import com.datingapp.shared.dataobjects.LoginInformation;
import com.datingapp.shared.dataobjects.Match;
import com.datingapp.shared.dataobjects.Profile;
import com.datingapp.utility.DateUtil;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;

public class DataPersistence {

    /**
     * This gets an existing profile from the database.
     *
     * @param _id Id to use to find the profile.
     * @return Existing Profile or null if it could not be found.
     * @throws SQLException If there was an issue communicating with the database.
     */
    public static Profile loadProfileById(long _id) throws SQLException {
        String sql = "SELECT * FROM Profiles WHERE Profile_ID=?";
        Connection connection = Database.getConnection();
        try {
            PreparedStatement statement = connection.prepareStatement(sql);
            try {
                statement.setLong(1, _id);
                ResultSet resultSet = statement.executeQuery();
                if (!resultSet.next()) {
                    //should display some kind of error message
                    return null;
                }
                try {
                    return new Profile(resultSet.getLong("Profile_ID"),
                        resultSet.getInt("Profile_Age"),
                        resultSet.getString("Profile_Name"),
                        resultSet.getString("Profile_Message"));
                } finally {
                    resultSet.close();
                }
            } finally {
                statement.close();
            }
        } finally {
            connection.close();
        }
    }

    /*
     * @return Match generated by SQL table
     * @param _id ID of the match to load
     * @throws SQLException if there was a problem communicating with the database
     */
    public static Match loadMatchById(long _id) throws SQLException {
        String sql = "SELECT * FROM Matched WHERE Matched_ID=?";
        Connection connection = Database.getConnection();
        try {
            PreparedStatement statement = connection.prepareStatement(sql);
            try {
                statement.setLong(1, _id);
                ResultSet resultSet = statement.executeQuery();
                if (!resultSet.next()) {
                    //should display some kind of error message
                    return null;
                }
                try {
                    /* Because the match object is constructed using profile objects themselves, we must
                     *  instantiate new profile objects using loadProfileById.
                     */
                    return new Match(resultSet.getLong("Matched_ID"),
                            loadProfileById(resultSet.getLong("Profile_1_ID")),
                            loadProfileById(resultSet.getLong("Profile_2_ID")),
                            resultSet.getObject("Matched_Date"),
                            resultSet.getBoolean("active"));
                } finally {
                    resultSet.close();
                }
            } finally {
                statement.close();
            }
        } finally {
            connection.close();
        }
    }

    /**
     * The purpose of this function is to save a profile to the database. If the id is equal to the
     * DatabasePersistenceConstants.UNASSIGNED_ID field, then the profile is inserted instead of
     * being updated.
     * @param _profile The profile to insert or update the database with.
     * @throws SQLException If there was an issue applying the changes to the database.
     */
    public static void save(Profile _profile) throws SQLException {
        Connection connection = Database.getConnection();
        try {
            /*ClassScraper is used here to read the private profile ID, which is used to determine if the profile
             *  exists in the database.
             */
            ClassScraper profileScraper = new ClassScraper<>(Profile.class);
            long id = (Long)profileScraper.read(_profile, "id", Long.class);
            /*
             * This if-else statement checks if the profile is already in the database, updates it if it exists,
             *  and inserts it if it does not.
             */
            if (id > 0) {
                updateProfile(connection, _profile, id);
            } else {
                _profile = insertProfile(connection, profileScraper, _profile);
            }
        } finally {
            connection.close();
        }
    }

    /* helper method that handles the logic of updating an existing profile in the database
     * @param _connection is the database connection from the save method
     * @param _passedProfile is the the Profile object that is being updated in the database (value = _profile in save method)
     * @param _id is the id of the profile being updated (scraped by profileScraper in the save method)
     */
    private static void updateProfile(Connection _connection, Profile _passedProfile, Long _id) throws  SQLException{
        String sql = "UPDATE Profiles SET Profile_Age=?, Profile_Name=?, Profile_Message=?, IntroVideo_ID=? WHERE Profile_ID=?";
        PreparedStatement statement = _connection.prepareStatement(sql);
        try {
            statement.setInt(1, _passedProfile.getAge());
            statement.setString(2, _passedProfile.getName());
            statement.setString(3, _passedProfile.getPersonalMessage());
            statement.setNull(4, Types.BIGINT);
            statement.setLong(5, _id);
            statement.execute();
        } finally {
            statement.close();
        }
    }

    /* helper method that handles the logic of inserting a profile into the database
     * @return _passedProfile
     * @param _connection is the database connection from the save method
     * @param _profileScraper is the ClassScraper used to access variables from _passedProfile
     * @param _passedProfile is the Profile object that is being updated (inserted in this case) in the database (value = _profile in save method)
     */
    private static Profile insertProfile(Connection _connection, ClassScraper _profileScraper, Profile _passedProfile) throws SQLException{
        String sql = "INSERT INTO Profiles (Profile_Age, Profile_Name, Profile_Message, IntroVideo_ID) VALUES (?, ?, ?, ?);";
        PreparedStatement statement = _connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        System.out.println(_passedProfile.getName());
        try {
            statement.setInt(1, _passedProfile.getAge());
            statement.setString(2, _passedProfile.getName());
            statement.setString(3, _passedProfile.getPersonalMessage());
            statement.setNull(4, Types.BIGINT);
            statement.execute();
            ResultSet resultSet = statement.getGeneratedKeys();
            //Writes the auto-incremented ID from the database to the _passedProfile object
            try {
                Long assignedId = resultSet.getLong("Profile_ID");
                _profileScraper.write(_passedProfile, "id", assignedId);
            } finally {
                resultSet.close();
            }
        } finally {
            statement.close();
            return _passedProfile;
        }
    }



    /*
     * The purpose of this class is to save a match to the database involving exactly two profiles
     * and set it to active.
     * @params _profile1 and _profile2, the two profiles being matched
     */

    public static Match save(Match _match) throws SQLException {
        Connection connection = Database.getConnection();
        ClassScraper matchScraper = new ClassScraper<>(Match.class);
        long id = (Long)matchScraper.read(_match, "id", Long.class);
        try {
            if (id>0) {
                updateMatch(connection, _match, id);
            } else {
                _match = insertMatch(connection, matchScraper, _match);
                matchScraper.write(_match, "id", _match.getId());
            }
        } finally {
            connection.close();
            return _match;
        }
    }

    /*
     * helper method that updates an existing match in the database
     * @param _connection is the db connection from the save method
     * @param _passedMatch is the match being updated (value = _match param from save method)
     * @param _id is the id of the match in the db (scraped by matchScraper in save method)
     */
    private static void updateMatch(Connection _connection, Match _passedMatch, Long _id) throws SQLException {
        final String sql = "UPDATE Matched (Profile_1_ID, Profile_2_ID, Matched_Date, active) VALUE (?,?,?,?) WHERE Matched_ID=?;";
        PreparedStatement statement = _connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        try {
            statement.setLong(1, _passedMatch.getFirstProfile().getId());
            statement.setLong(2, _passedMatch.getSecondProfile().getId());
            statement.setObject(3, DateUtil.getCurrentDateAndTime());
            statement.setBoolean(4, _passedMatch.getIsActive());
            statement.setLong(5, _id);
            statement.execute();
        }
        finally {
            statement.close();
        }
    }

    /*
     * helper method that inserts a match into the database
     * @return _passedMatch
     * @param _connection is the database connection from the save method
     * @param _matchScraper is the ClassScraper used to access private fields from the match being inserted
     * @param _passedMatch is the match being inserted into the database (value = _match param in save method)
     */
    private static Match insertMatch(Connection _connection, ClassScraper _matchScraper, Match _passedMatch) throws SQLException {
        String sql = "INSERT INTO Matched (Profile_1_ID, Profile_2_ID, Matched_Date, active) VALUE (?,?,?,?)";
        PreparedStatement statement = _connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        try {
            statement.setLong(1, _passedMatch.getFirstProfile().getId());
            statement.setLong(2, _passedMatch.getSecondProfile().getId());
            //date is currently null while I figure that out
            statement.setObject(3, null);
            statement.setBoolean(4, _passedMatch.getIsActive());
            statement.execute();
            ResultSet resultSet = statement.getGeneratedKeys();
            //writes the auto-incremented ID to the _passedMatch object
            try {
                Long assignedId = resultSet.getLong("Matched_ID");
                _passedMatch.setId(assignedId);

            } finally {
                resultSet.close();
            }
        } finally {
            statement.close();
            return _passedMatch;
        }
    }

    public static void save(LoginInformation _loginInfo) {

    }

    public static LoginInformation loadLogin(String _email) {
        return null;
    }

    public static void main(String args[]) throws SQLException {
        Profile pfPersonson = new Profile(21, "Personson", "Yo whaddup bitches");
        save(pfPersonson);
        Profile pfPersonator = new Profile(23, "Personator", "I'm what's up bitch");
        save(pfPersonator);
        Match personsonAtorMatch = new Match(loadProfileById(21), loadProfileById(20), null, true);
        save(personsonAtorMatch);
//        System.out.println(personsonAtorMatch.getFirstProfile().getId());
    }
}
